initSidebarItems({"enum":[["DelayedLiteral",""],["InnerDelayedLiteralSets",""],["Literal","Either `A` or `~A`, where `A` is a `Env |- Goal`."]],"fn":[["maybe_grow_stack","Because we recurse so deeply, we rely on stacker to avoid overflowing the stack."]],"mod":[["context","Defines traits used to embed the chalk-engine in another crate."],["derived",""],["fallible",""],["forest",""],["hh",""],["logic",""],["simplify",""],["stack",""],["strand",""],["table",""],["tables",""]],"struct":[["DelayedLiteralSet","A set of delayed literals."],["DelayedLiteralSets",""],["DepthFirstNumber","The `DepthFirstNumber` (DFN) is a sequential number assigned to each goal when it is first encountered. The naming (taken from EWFS) refers to the idea that this number tracks the index of when we encounter the goal during a depth-first traversal of the proof tree."],["ExClause","The paper describes these as `A :- D | G`."],["FlounderedSubgoal","A \"floundered\" subgoal is one that contains unbound existential variables for which it cannot produce a value. The classic example of flounding is a negative subgoal:"],["Minimums","The `Minimums` structure is used to track the dependencies between some item E on the evaluation stack. In particular, it tracks cases where the success of E depends (or may depend) on items deeper in the stack than E (i.e., with lower DFNs)."],["SimplifiedAnswer",""],["SimplifiedAnswers",""],["StackIndex",""],["TableIndex",""],["TimeStamp","The \"time stamp\" is a simple clock that gets incremented each time we encounter a positive answer in processing a particular strand. This is used as an optimization to help us figure out when we may have changed inference variables."]]});
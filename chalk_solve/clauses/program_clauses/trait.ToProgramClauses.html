<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `ToProgramClauses` trait in crate `chalk_solve`."><meta name="keywords" content="rust, rustlang, rust-lang, ToProgramClauses"><title>chalk_solve::clauses::program_clauses::ToProgramClauses - Rust</title><link rel="stylesheet" type="text/css" href="../../../normalize.css"><link rel="stylesheet" type="text/css" href="../../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../../dark.css"><link rel="stylesheet" type="text/css" href="../../../light.css" id="themeStyle"><script src="../../../storage.js"></script><noscript><link rel="stylesheet" href="../../../noscript.css"></noscript><link rel="shortcut icon" href="../../../favicon.ico"><style type="text/css">#crate-search{background-image:url("../../../down-arrow.svg");}</style></head><body class="rustdoc trait"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../../../chalk_solve/index.html'><div class='logo-container'><img src='../../../rust-logo.png' alt='logo'></div></a><p class='location'>Trait ToProgramClauses</p><div class="sidebar-elems"><div class="block items"><a class="sidebar-title" href="#required-methods">Required Methods</a><div class="sidebar-links"><a href="#tymethod.to_program_clauses">to_program_clauses</a></div><a class="sidebar-title" href="#foreign-impls">Implementations on Foreign Types</a><div class="sidebar-links"><a href="#impl-ToProgramClauses-for-AssociatedTyDatum">AssociatedTyDatum</a><a href="#impl-ToProgramClauses-for-AssociatedTyValue">AssociatedTyValue</a><a href="#impl-ToProgramClauses-for-ImplDatum">ImplDatum</a><a href="#impl-ToProgramClauses-for-StructDatum">StructDatum</a><a href="#impl-ToProgramClauses-for-TraitDatum">TraitDatum</a></div><a class="sidebar-title" href="#implementors">Implementors</a></div><p class='location'><a href='../../index.html'>chalk_solve</a>::<wbr><a href='../index.html'>clauses</a>::<wbr><a href='index.html'>program_clauses</a></p><script>window.sidebarCurrent = {name: 'ToProgramClauses', ty: 'trait', relpath: ''};</script><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../../../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../../../theme.js"></script><nav class="sub"><form class="search-form js-only"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><a id="settings-menu" href="../../../settings.html"><img src="../../../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../../../src/chalk_solve/clauses/program_clauses.rs.html#12-14' title='goto source code'>[src]</a></span><span class='in-band'>Trait <a href='../../index.html'>chalk_solve</a>::<wbr><a href='../index.html'>clauses</a>::<wbr><a href='index.html'>program_clauses</a>::<wbr><a class="trait" href=''>ToProgramClauses</a></span></h1><div class="docblock type-decl hidden-by-usual-hider"><pre class='rust trait'>pub trait ToProgramClauses {
    fn <a href='#tymethod.to_program_clauses' class='fnname'>to_program_clauses</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;db: &amp;dyn <a class="trait" href="../../../chalk_solve/trait.RustIrDatabase.html" title="trait chalk_solve::RustIrDatabase">RustIrDatabase</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clauses: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="enum" href="../../../chalk_ir/enum.ProgramClause.html" title="enum chalk_ir::ProgramClause">ProgramClause</a>&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;);
}</pre></div><div class='docblock'><p>Trait for lowering a given piece of rust-ir source (e.g., an impl
or struct definition) into its associated &quot;program clauses&quot; --
that is, into the lowered, logical rules that it defines.</p>
</div>
            <h2 id='required-methods' class='small-section-header'>Required methods<a href='#required-methods' class='anchor'></a></h2><div class='methods'><h3 id='tymethod.to_program_clauses' class='method'><code id='to_program_clauses.v'>fn <a href='#tymethod.to_program_clauses' class='fnname'>to_program_clauses</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;db: &amp;dyn <a class="trait" href="../../../chalk_solve/trait.RustIrDatabase.html" title="trait chalk_solve::RustIrDatabase">RustIrDatabase</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;clauses: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="enum" href="../../../chalk_ir/enum.ProgramClause.html" title="enum chalk_ir::ProgramClause">ProgramClause</a>&gt;<br>)</code></h3></div><span class='loading-content'>Loading content...</span>
            <h2 id='foreign-impls' class='small-section-header'>Implementations on Foreign Types<a href='#foreign-impls' class='anchor'></a></h2><h3 id='impl-ToProgramClauses-for-ImplDatum' class='impl'><code class='in-band'>impl <a class="trait" href="../../../chalk_solve/clauses/program_clauses/trait.ToProgramClauses.html" title="trait chalk_solve::clauses::program_clauses::ToProgramClauses">ToProgramClauses</a> for <a class="struct" href="../../../chalk_rust_ir/struct.ImplDatum.html" title="struct chalk_rust_ir::ImplDatum">ImplDatum</a></code><a href='#impl-ToProgramClauses-for-ImplDatum' class='anchor'></a><a class='srclink' href='../../../src/chalk_solve/clauses/program_clauses.rs.html#16-42' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.to_program_clauses' class="method"><code id='to_program_clauses.v-1'>fn <a href='#method.to_program_clauses' class='fnname'>to_program_clauses</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;_db: &amp;dyn <a class="trait" href="../../../chalk_solve/trait.RustIrDatabase.html" title="trait chalk_solve::RustIrDatabase">RustIrDatabase</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;clauses: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="enum" href="../../../chalk_ir/enum.ProgramClause.html" title="enum chalk_ir::ProgramClause">ProgramClause</a>&gt;<br>)</code><a class='srclink' href='../../../src/chalk_solve/clauses/program_clauses.rs.html#30-41' title='goto source code'>[src]</a></h4><div class='docblock'><p>Given <code>impl&lt;T: Clone&gt; Clone for Vec&lt;T&gt; { ... }</code>, generate:</p>
<pre><code class="language-notrust">-- Rule Implemented-From-Impl
forall&lt;T&gt; {
    Implemented(Vec&lt;T&gt;: Clone) :- Implemented(T: Clone).
}
</code></pre>
<p>For a negative impl like <code>impl... !Clone for ...</code>, however, we
generate nothing -- this is just a way to <em>opt out</em> from the
default auto trait impls, it doesn't have any positive effect
on its own.</p>
</div></div><h3 id='impl-ToProgramClauses-for-AssociatedTyValue' class='impl'><code class='in-band'>impl <a class="trait" href="../../../chalk_solve/clauses/program_clauses/trait.ToProgramClauses.html" title="trait chalk_solve::clauses::program_clauses::ToProgramClauses">ToProgramClauses</a> for <a class="struct" href="../../../chalk_rust_ir/struct.AssociatedTyValue.html" title="struct chalk_rust_ir::AssociatedTyValue">AssociatedTyValue</a></code><a href='#impl-ToProgramClauses-for-AssociatedTyValue' class='anchor'></a><a class='srclink' href='../../../src/chalk_solve/clauses/program_clauses.rs.html#44-170' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.to_program_clauses-1' class="method"><code id='to_program_clauses.v-2'>fn <a href='#method.to_program_clauses' class='fnname'>to_program_clauses</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;db: &amp;dyn <a class="trait" href="../../../chalk_solve/trait.RustIrDatabase.html" title="trait chalk_solve::RustIrDatabase">RustIrDatabase</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;clauses: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="enum" href="../../../chalk_ir/enum.ProgramClause.html" title="enum chalk_ir::ProgramClause">ProgramClause</a>&gt;<br>)</code><a class='srclink' href='../../../src/chalk_solve/clauses/program_clauses.rs.html#80-169' title='goto source code'>[src]</a></h4><div class='docblock'><p>Given the following trait:</p>
<pre><code class="language-notrust">trait Iterable {
    type IntoIter&lt;'a&gt;: 'a;
}
</code></pre>
<p>Then for the following impl:</p>
<pre><code class="language-notrust">impl&lt;T&gt; Iterable for Vec&lt;T&gt; where T: Clone {
    type IntoIter&lt;'a&gt; = Iter&lt;'a, T&gt;;
}
</code></pre>
<p>we generate:</p>
<pre><code class="language-notrust">-- Rule Normalize-From-Impl
forall&lt;'a, T&gt; {
    Normalize(&lt;Vec&lt;T&gt; as Iterable&gt;::IntoIter&lt;'a&gt; -&gt; Iter&lt;'a, T&gt;&gt;) :-
        Implemented(T: Clone),  // (1)
        Implemented(Iter&lt;'a, T&gt;: 'a).   // (2)
}
</code></pre>
<p>and:</p>
<pre><code class="language-notrust">forall&lt;'a, T&gt; {
    UnselectedNormalize(Vec&lt;T&gt;::IntoIter&lt;'a&gt; -&gt; Iter&lt;'a, T&gt;) :-
        InScope(Iterable),
        Normalize(&lt;Vec&lt;T&gt; as Iterable&gt;::IntoIter&lt;'a&gt; -&gt; Iter&lt;'a, T&gt;).
}
</code></pre>
</div></div><h3 id='impl-ToProgramClauses-for-StructDatum' class='impl'><code class='in-band'>impl <a class="trait" href="../../../chalk_solve/clauses/program_clauses/trait.ToProgramClauses.html" title="trait chalk_solve::clauses::program_clauses::ToProgramClauses">ToProgramClauses</a> for <a class="struct" href="../../../chalk_rust_ir/struct.StructDatum.html" title="struct chalk_rust_ir::StructDatum">StructDatum</a></code><a href='#impl-ToProgramClauses-for-StructDatum' class='anchor'></a><a class='srclink' href='../../../src/chalk_solve/clauses/program_clauses.rs.html#172-348' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.to_program_clauses-2' class="method"><code id='to_program_clauses.v-3'>fn <a href='#method.to_program_clauses' class='fnname'>to_program_clauses</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;_db: &amp;dyn <a class="trait" href="../../../chalk_solve/trait.RustIrDatabase.html" title="trait chalk_solve::RustIrDatabase">RustIrDatabase</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;clauses: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="enum" href="../../../chalk_ir/enum.ProgramClause.html" title="enum chalk_ir::ProgramClause">ProgramClause</a>&gt;<br>)</code><a class='srclink' href='../../../src/chalk_solve/clauses/program_clauses.rs.html#221-347' title='goto source code'>[src]</a></h4><div class='docblock'><p>Given the following type definition: <code>struct Foo&lt;T: Eq&gt; { }</code>, generate:</p>
<pre><code class="language-notrust">-- Rule WellFormed-Type
forall&lt;T&gt; {
    WF(Foo&lt;T&gt;) :- WF(T: Eq).
}

-- Rule Implied-Bound-From-Type
forall&lt;T&gt; {
    FromEnv(T: Eq) :- FromEnv(Foo&lt;T&gt;).
}

forall&lt;T&gt; {
    IsFullyVisible(Foo&lt;T&gt;) :- IsFullyVisible(T).
}
</code></pre>
<p>If the type <code>Foo</code> is marked <code>#[upstream]</code>, we also generate:</p>
<pre><code class="language-notrust">forall&lt;T&gt; { IsUpstream(Foo&lt;T&gt;). }
</code></pre>
<p>Otherwise, if the type <code>Foo</code> is not marked <code>#[upstream]</code>, we generate:</p>
<pre><code class="language-notrust">forall&lt;T&gt; { IsLocal(Foo&lt;T&gt;). }
</code></pre>
<p>Given an <code>#[upstream]</code> type that is also fundamental:</p>
<pre><code class="language-notrust">#[upstream]
#[fundamental]
struct Box&lt;T&gt; {}
</code></pre>
<p>We generate the following clauses:</p>
<pre><code class="language-notrust">forall&lt;T&gt; { IsLocal(Box&lt;T&gt;) :- IsLocal(T). }

forall&lt;T&gt; { IsUpstream(Box&lt;T&gt;) :- IsUpstream(T). }

// Generated for both upstream and local fundamental types
forall&lt;T&gt; { DownstreamType(Box&lt;T&gt;) :- DownstreamType(T). }
</code></pre>
</div></div><h3 id='impl-ToProgramClauses-for-TraitDatum' class='impl'><code class='in-band'>impl <a class="trait" href="../../../chalk_solve/clauses/program_clauses/trait.ToProgramClauses.html" title="trait chalk_solve::clauses::program_clauses::ToProgramClauses">ToProgramClauses</a> for <a class="struct" href="../../../chalk_rust_ir/struct.TraitDatum.html" title="struct chalk_rust_ir::TraitDatum">TraitDatum</a></code><a href='#impl-ToProgramClauses-for-TraitDatum' class='anchor'></a><a class='srclink' href='../../../src/chalk_solve/clauses/program_clauses.rs.html#350-618' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.to_program_clauses-3' class="method"><code id='to_program_clauses.v-4'>fn <a href='#method.to_program_clauses' class='fnname'>to_program_clauses</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;_db: &amp;dyn <a class="trait" href="../../../chalk_solve/trait.RustIrDatabase.html" title="trait chalk_solve::RustIrDatabase">RustIrDatabase</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;clauses: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="enum" href="../../../chalk_ir/enum.ProgramClause.html" title="enum chalk_ir::ProgramClause">ProgramClause</a>&gt;<br>)</code><a class='srclink' href='../../../src/chalk_solve/clauses/program_clauses.rs.html#464-617' title='goto source code'>[src]</a></h4><div class='docblock'><p>Given the following trait declaration: <code>trait Ord&lt;T&gt; where Self: Eq&lt;T&gt; { ... }</code>, generate:</p>
<pre><code class="language-notrust">-- Rule WellFormed-TraitRef
forall&lt;Self, T&gt; {
   WF(Self: Ord&lt;T&gt;) :- Implemented(Self: Ord&lt;T&gt;), WF(Self: Eq&lt;T&gt;).
}
</code></pre>
<p>and the reverse rules:</p>
<pre><code class="language-notrust">-- Rule Implemented-From-Env
forall&lt;Self, T&gt; {
   (Self: Ord&lt;T&gt;) :- FromEnv(Self: Ord&lt;T&gt;).
}

-- Rule Implied-Bound-From-Trait
forall&lt;Self, T&gt; {
    FromEnv(Self: Eq&lt;T&gt;) :- FromEnv(Self: Ord&lt;T&gt;).
}
</code></pre>
<p>As specified in the orphan rules, if a trait is not marked <code>#[upstream]</code>, the current crate
can implement it for any type. To represent that, we generate:</p>
<pre><code class="language-notrust">// `Ord&lt;T&gt;` would not be `#[upstream]` when compiling `std`
forall&lt;Self, T&gt; { LocalImplAllowed(Self: Ord&lt;T&gt;). }
</code></pre>
<p>For traits that are <code>#[upstream]</code> (i.e. not in the current crate), the orphan rules dictate
that impls are allowed as long as at least one type parameter is local and each type
prior to that is fully visible. That means that each type prior to the first local
type cannot contain any of the type parameters of the impl.</p>
<p>This rule is fairly complex, so we expand it and generate a program clause for each
possible case. This is represented as follows:</p>
<pre><code class="language-notrust">// for `#[upstream] trait Foo&lt;T, U, V&gt; where Self: Eq&lt;T&gt; { ... }`
forall&lt;Self, T, U, V&gt; {
    LocalImplAllowed(Self: Foo&lt;T, U, V&gt;) :- IsLocal(Self).
}

forall&lt;Self, T, U, V&gt; {
    LocalImplAllowed(Self: Foo&lt;T, U, V&gt;) :-
        IsFullyVisible(Self),
        IsLocal(T).
}

forall&lt;Self, T, U, V&gt; {
    LocalImplAllowed(Self: Foo&lt;T, U, V&gt;) :-
        IsFullyVisible(Self),
        IsFullyVisible(T),
        IsLocal(U).
}

forall&lt;Self, T, U, V&gt; {
    LocalImplAllowed(Self: Foo&lt;T, U, V&gt;) :-
        IsFullyVisible(Self),
        IsFullyVisible(T),
        IsFullyVisible(U),
        IsLocal(V).
}
</code></pre>
<p>The overlap check uses compatible { ... } mode to ensure that it accounts for impls that
may exist in some other <em>compatible</em> world. For every upstream trait, we add a rule to
account for the fact that upstream crates are able to compatibly add impls of upstream
traits for upstream types.</p>
<pre><code class="language-notrust">// For `#[upstream] trait Foo&lt;T, U, V&gt; where Self: Eq&lt;T&gt; { ... }`
forall&lt;Self, T, U, V&gt; {
    Implemented(Self: Foo&lt;T, U, V&gt;) :-
        Implemented(Self: Eq&lt;T&gt;), // where clauses
        Compatible,               // compatible modality
        IsUpstream(Self),
        IsUpstream(T),
        IsUpstream(U),
        IsUpstream(V),
        CannotProve.              // returns ambiguous
}
</code></pre>
<p>In certain situations, this is too restrictive. Consider the following code:</p>
<pre><code class="language-notrust">/* In crate std */
trait Sized { }
struct str { }

/* In crate bar (depends on std) */
trait Bar { }
impl Bar for str { }
impl&lt;T&gt; Bar for T where T: Sized { }
</code></pre>
<p>Here, because of the rules we've defined, these two impls overlap. The std crate is
upstream to bar, and thus it is allowed to compatibly implement Sized for str. If str
can implement Sized in a compatible future, these two impls definitely overlap since the
second impl covers all types that implement Sized.</p>
<p>The solution we've got right now is to mark Sized as &quot;fundamental&quot; when it is defined.
This signals to the Rust compiler that it can rely on the fact that str does not
implement Sized in all contexts. A consequence of this is that we can no longer add an
implementation of Sized compatibly for str. This is the trade off you make when defining
a fundamental trait.</p>
<p>To implement fundamental traits, we simply just do not add the rule above that allows
upstream types to implement upstream traits. Fundamental traits are not allowed to
compatibly do that.</p>
</div></div><h3 id='impl-ToProgramClauses-for-AssociatedTyDatum' class='impl'><code class='in-band'>impl <a class="trait" href="../../../chalk_solve/clauses/program_clauses/trait.ToProgramClauses.html" title="trait chalk_solve::clauses::program_clauses::ToProgramClauses">ToProgramClauses</a> for <a class="struct" href="../../../chalk_rust_ir/struct.AssociatedTyDatum.html" title="struct chalk_rust_ir::AssociatedTyDatum">AssociatedTyDatum</a></code><a href='#impl-ToProgramClauses-for-AssociatedTyDatum' class='anchor'></a><a class='srclink' href='../../../src/chalk_solve/clauses/program_clauses.rs.html#620-863' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.to_program_clauses-4' class="method"><code id='to_program_clauses.v-5'>fn <a href='#method.to_program_clauses' class='fnname'>to_program_clauses</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;db: &amp;dyn <a class="trait" href="../../../chalk_solve/trait.RustIrDatabase.html" title="trait chalk_solve::RustIrDatabase">RustIrDatabase</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;clauses: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="enum" href="../../../chalk_ir/enum.ProgramClause.html" title="enum chalk_ir::ProgramClause">ProgramClause</a>&gt;<br>)</code><a class='srclink' href='../../../src/chalk_solve/clauses/program_clauses.rs.html#689-862' title='goto source code'>[src]</a></h4><div class='docblock'><p>For each associated type, we define the &quot;projection
equality&quot; rules. There are always two; one for a successful normalization,
and one for the &quot;fallback&quot; notion of equality.</p>
<p>Given: (here, <code>'a</code> and <code>T</code> represent zero or more parameters)</p>
<pre><code class="language-notrust">trait Foo {
    type Assoc&lt;'a, T&gt;: Bounds where WC;
}
</code></pre>
<p>we generate the 'fallback' rule:</p>
<pre><code class="language-notrust">-- Rule ProjectionEq-Placeholder
forall&lt;Self, 'a, T&gt; {
    ProjectionEq(&lt;Self as Foo&gt;::Assoc&lt;'a, T&gt; = (Foo::Assoc&lt;'a, T&gt;)&lt;Self&gt;).
}
</code></pre>
<p>and</p>
<pre><code class="language-notrust">-- Rule ProjectionEq-Normalize
forall&lt;Self, 'a, T, U&gt; {
    ProjectionEq(&lt;T as Foo&gt;::Assoc&lt;'a, T&gt; = U) :-
        Normalize(&lt;T as Foo&gt;::Assoc -&gt; U).
}
</code></pre>
<p>We used to generate an &quot;elaboration&quot; rule like this:</p>
<pre><code class="language-notrust">forall&lt;T&gt; {
    T: Foo :- exists&lt;U&gt; { ProjectionEq(&lt;T as Foo&gt;::Assoc = U) }.
}
</code></pre>
<p>but this caused problems with the recursive solver. In
particular, whenever normalization is possible, we cannot
solve that projection uniquely, since we can now elaborate
<code>ProjectionEq</code> to fallback <em>or</em> normalize it. So instead we
handle this kind of reasoning through the <code>FromEnv</code> predicate.</p>
<p>We also generate rules specific to WF requirements and implied bounds:</p>
<pre><code class="language-notrust">-- Rule WellFormed-AssocTy
forall&lt;Self, 'a, T&gt; {
    WellFormed((Foo::Assoc)&lt;Self, 'a, T&gt;) :- WellFormed(Self: Foo), WellFormed(WC).
}

-- Rule Implied-WC-From-AssocTy
forall&lt;Self, 'a, T&gt; {
    FromEnv(WC) :- FromEnv((Foo::Assoc)&lt;Self, 'a, T&gt;).
}

-- Rule Implied-Bound-From-AssocTy
forall&lt;Self, 'a, T&gt; {
    FromEnv(&lt;Self as Foo&gt;::Assoc&lt;'a,T&gt;: Bounds) :- FromEnv(Self: Foo), WC.
}

-- Rule Implied-Trait-From-AssocTy
forall&lt;Self,'a, T&gt; {
    FromEnv(Self: Foo) :- FromEnv((Foo::Assoc)&lt;Self, 'a,T&gt;).
}
</code></pre>
</div></div><span class='loading-content'>Loading content...</span>
            <h2 id='implementors' class='small-section-header'>Implementors<a href='#implementors' class='anchor'></a></h2><div class='item-list' id='implementors-list'></div><span class='loading-content'>Loading content...</span><script type="text/javascript">window.inlined_types=new Set([]);</script><script type="text/javascript" async
                         src="../../../implementors/chalk_solve/clauses/program_clauses/trait.ToProgramClauses.js">
                 </script></section><section id="search" class="content hidden"></section><section class="footer"></section><aside id="help" class="hidden"><div><h1 class="hidden">Help</h1><div class="shortcuts"><h2>Keyboard Shortcuts</h2><dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd><dt><kbd>S</kbd></dt><dd>Focus the search field</dd><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd><dt><kbd>↹</kbd></dt><dd>Switch tab</dd><dt><kbd>&#9166;</kbd></dt><dd>Go to active search result</dd><dt><kbd>+</kbd></dt><dd>Expand all sections</dd><dt><kbd>-</kbd></dt><dd>Collapse all sections</dd></dl></div><div class="infos"><h2>Search Tricks</h2><p>Prefix searches with a type followed by a colon (e.g., <code>fn:</code>) to restrict the search to a given type.</p><p>Accepted types are: <code>fn</code>, <code>mod</code>, <code>struct</code>, <code>enum</code>, <code>trait</code>, <code>type</code>, <code>macro</code>, and <code>const</code>.</p><p>Search functions by type signature (e.g., <code>vec -> usize</code> or <code>* -> vec</code>)</p><p>Search multiple things at once by splitting your query with comma (e.g., <code>str,u8</code> or <code>String,struct:Vec,test</code>)</p></div></div></aside><script>window.rootPath = "../../../";window.currentCrate = "chalk_solve";</script><script src="../../../aliases.js"></script><script src="../../../main.js"></script><script defer src="../../../search-index.js"></script></body></html>